---
layout: post
title:  "Java锁优化技术"
subtitle:  " \"optimal lock \""
date:   2018-01-09 21:23:18 +0800
tags:
    - Java
author: Nian Tianlei
header-img: "img/post-bg-2016.jpg"
header-mask: 0.4
catalog:    true
---

### 尽量减少锁的持有时间
在编写程序时，应尽量减少锁的持有时间，仅在有线程安全要求的代码周围加锁，但是也要考虑到不要频繁地加锁/解锁，避免性能损失。  
### 减小锁粒度
将共享数据分组，减少对同一把锁的竞争，比如Java8的`ConcurrentHashMap`，其实现在[另一篇博客](https://niantianlei.github.io/2017/12/28/ConcurrentHashMap/)中已经分析过。  
### 锁分离技术
比如读写锁，不仅提高了读的性能，也保证了线程的安全。也有[博文分析过](https://niantianlei.github.io/2017/07/24/java-lock/)。其特点是读读共享、读写互斥、写写互斥。  
### 自适应自旋
如果两个线程同时执行，没有获得锁的线程稍微等一等，看看第一个线程是否很快就会释放锁。第二个线程不放弃处理器执行时间，而是执行一个忙循环（自旋），进行等待。  

自旋锁默认是开启的。自旋不能代替阻塞，虽然避免了线程切换的开销，但占用处理器时间，如果自旋时间长会白白浪费大量处理器资源。可以使用``-XX:PreBlockSpin``参数更改自旋等待的次数。默认10次。  

自适应自旋：如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。同样地，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。  
### 锁消除
虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持，如果堆上的数据不会逃逸出去被其他线程访问，那么锁就是没必要的，可以消除。  

**逃逸分析：**基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。  
### 锁粗化
根据本文第一条锁优化的经验来看，总是尽量将同步块的范围缩小，但不能一味的追求最小的同步作用域。  
如果一系列的连续操作都对同一个对象反复加锁和解锁，将会把加锁同步的范围粗化到整个操作序列的外部，避免不必要的性能损耗。  

![coarsing]({{ "/img/post/lock-optimization/coarsing.png" | prepend: site.baseurl }} )  
毫无疑问，第二个方法的执行速度更快。  
### 轻量级锁
首先简单介绍对象的内存布局：  
对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。  
对象头包含三部分：1.存储对象自身的运行时数据，哈希码、GC分代年龄、锁状态标志等，官方称为"Mark Word"，这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit。  2.类型指针，对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  3.数组长度  
其中第3部分只有数组对象才有。  

对象头是实现轻量级锁和偏向锁的关键。  
线程在执行同步块之前，虚拟机会在当前线程的栈帧中建立一个存储锁记录的空间，并将Mark Word复制到锁记录中（官方称为Displaced Mark Word）。然后，虚拟机用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针。如果成功，当前线程获得锁，并将锁标志位改为00；如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获得锁。自旋仍失败，说明有竞争，锁膨胀为重量级锁。    

轻量级锁的解锁，会使用CAS操作将Displaced Mark Word替换回对象头，如果成功，表示没有竞争发生；如果失败，表示有其他线程尝试过获取锁，就要在释放锁的同时，唤醒被挂起的线程。  
### 偏向锁
目的是消除数据在无竞争情况下的同步，进一步提高程序的运行性能。  

当一个线程访问同步块并获取锁时，虚拟机将会把对象头中的标志位设为01，同时使用CAS操作把获取到这个锁的线程ID记录到Mark Word中，如果CAS操作成功，以后该线程在进入和退出同步块时不需要加锁和解锁，只需要检查Mark Word中是否存有指向当前线程的偏向锁。    

当另外一个线程去尝试获取这个锁时，偏向模式就结束了。恢复到未锁定01或轻量级锁定00状态。  