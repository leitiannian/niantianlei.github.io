---
layout: post
title:  "MySQL性能优化"
subtitle:  " \"optimize the performance of MySQL\""
date:   2017-8-21 11:28:18 +0800
tags:
    - MySQL
author: Nian Tianlei
header-img: "img/post-bg-2016.jpg"
header-mask: 0.4
catalog:    true
---

> 近期看了《高性能MySQL》这本书，写点关于性能提升的东西  


## 选择优化的数据类型

**1.更小的通常更好**  
应该尽量使用可以正确存储数据的最小数据类型，使表在磁盘上占据的空间尽可能小。这能带来性能非常大的提升，因为数据小，磁盘读入较快，并且在查询过程中表内容被处理所占用的内存更少。同时，在更小的列上建索引，索引也会占用更少的资源。  
**2.尽量简单**  
简答数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低。  
**3.尽量避免NULL**  
通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。  
## schema优化
**1.适当的进行水平分割与垂直分割**  
**2.对schema进行范式化设计**  
- 范式化的更新操作通常比反范式化要快。  
- 数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。  
- 范式化的表通常更小，执行更快。 

范式化设计的schema缺点是通常需要关联。  
反范式化的schema因为所有数据都在一张表中，可以很好的避免关联。  
因此，最好恰当混用范式化和反范式化设计。  
**3.缓存表和汇总表**  
缓存表存储可以简单地从schema其他表获取数据的表。  
汇总表保存使用GROUP BY语句聚合数据的表。  

## 创建高性能的索引
不同存储引擎的索引的工作方式不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现可能不同。  

**1.B-Tree索引**  
使用B-Tree数据结构来存储数据。大多数的MySQL都支持这种索引。Archive引擎是个例外，5.1之前不支持任何索引，5.1才开始支持单个自增列(AUTO_INCREMENT)的索引。  
InnoDB使用的B+Tree。  
存储引擎以不同的方式使用B-Tree索引，性能也不同。例如：MyISAM使用前缀压缩技术使得索引更小，但InnoDB按照原数据格式进行存储。再比如，MyISAM索引通过数据的物理位置引用被索引的行，InnoDB根据主键引用被索引的行。  
B-Tree索引能够加快访问数据的速度是因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根结点开始进行搜索。  
*B-Tree索引的限制：*  
1. 如果不是按照索引的最左列开始查找，则无法使用索引。  
2. 不能跳过索引中的列，例如三个key，查找指定第一个和第三个key值的，不行。  
3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。  

**2.哈希索引**  
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。  
在MySQL中，只有MEmory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。  
*哈希索引的限制：*  
1. 哈希索引只包含哈希值和行指针不存储字段值。  
2. 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。  
3. 哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。  
4. 哈希索引只支持等值比较查询。  
5. 哈希冲突很多的话，一些索引维护操作的代价也会很高。  

**3.空间数据索引(R-Tree)**  
MyISAM表支持空间索引，可以用作地理数据存储，这类索引无须前缀查询。

**4.全文索引**  
查找的是文本中的关键词，而不是直接比较索引中的值。5.6.4之前版本的MySQL只有MyISAM支持全文搜索。

<p style="font-size: 20px; font-weight: bold; color: red">高性能的索引策略</p>
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">1.使用独立的列</span>    
如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">2.前缀索引和索引选择性</span>  
不重复的索引值和数据表的记录总数的比值越高越好。  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">3.多列索引</span>  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">4.选择合适的索引列顺序</span>  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">5.聚簇索引</span>  
聚簇索引是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页。“聚簇”表示数据行和相邻的键值紧凑地存储在一起。  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">6.覆盖索引</span>   
如果一个索引包含所有需要查询的字段的值，就称之为“覆盖索引”。  
索引条目通常远小于数据行大小，如果只需要读取索引，将极大减少数据访问量。
因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。
一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。  
由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">7.压缩(前缀压缩)索引</span>   
MyISAM使用前缀压缩来减少索引的大小，使更多的索引可以放入内存中，提高性能。  
<span style="color: #0099ff; font-weight: bold; font-size: 17px;">8.冗余和重复索引以及未使用的索引</span>   
这些索引是不必要的

## 查询性能的优化
1.使用explain和profile分析查询语句  
2.是否向数据库请求了不需要的数据  
- 查询不需要的记录。应该加上LIMIT。
- 多表关联时返回全部列。应该只取需要的列。
- 总是取出全部列。SELECT * 的写法应尽量避免。
- 重复查询相同的数据。应该将数据缓存起来。

3.重构查询的方式  
确定一个复杂查询还是多个简单查询更加有效  。
切分查询。将大查询切分成小查询。每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。  
分解关联查询。对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。  

## 多使用视图、分区、存储结构等特性

## 优化服务器设置
*max_length_for_sort_data*和*sort_buffer_size*  
这两个参数尽量加大，以优化排序
*tmp_table_size*和*max_heap_table_size*  
控制使用Memory引擎的内存临时表能使用多大的内存。应把这两个变量设为同样的值，且不能太大，因为要把临时表放在内存里。  
*max_connections*  
保证服务器不会因应用程序激增的链接而不堪重负。应设置足够高，以容纳正常可能达到的负载。  
*table_cache_size*  
应设置足够大，避免总是需要重新打开和重新解析表的定义。  
*max_allowed_packet*  
应该设置足够大，以适应比较大的SQL查询，对性能没有太大影响，主要是避免出现packet错误。  
*max_connections*  
指每个数据库用户的最大连接，针对某一个账号的所有客户端并行连接到MYSQL服务的最大并行连接数。默认为0表示不限制，可改为500。  
*thread_concurrency*  
应设为cpu核心数的两倍。  
*thread_cache_size*  
服务器线程缓存，表示可以重新利用保存在缓存中线程的数量。应稍微大些。
*key_buffer_size*  
用于索引快的缓冲区大小。对MyISAM影响较大。  
对于InnoDB，最重要的是*innodb_buffer_pool_size*和*innodb_log_file_size*两个参数。

