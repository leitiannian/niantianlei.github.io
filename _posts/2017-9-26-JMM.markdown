---
layout:     post
title:      "Java内存模型"
subtitle:   " \"JMM\""

author:     "Nian Tianlei"
header-img: "img/post-bg-2016.jpg"
tags:
    - Java
---

> 下滑这里查看更多内容




最近看了个题，借此机会把Java内存模型总结复习一下  
```
public static void main(String[] args){
	int i = 0;
	i = i++;
}
```
输出的是0  

解释如下：
Java虚拟机栈（JVM Stack）描述的是Java方法执行的内存模型，而JVM内存模型是基于“栈帧”的，每个栈帧中都有 局部变量表 和 操作数栈 （还有动态链接、return address等），那么JVM是如何执行这个语句的呢？通过JDK自带的反编译器javap查看生成的指令执行代码。
![a]({{ "/img/post/JMM/javap.png" | prepend: site.baseurl }} )  

接下来分析一下JVM是如何执行的:  
0：将int类型的0入栈，就是放到操作数栈的栈顶  
1：将操作数栈栈顶的值0弹出，保存到局部变量表 index （索引）值为1的位置。局部变量表从1开始  
2：将局部变量表index=1位置的值的副本入栈。（这时局部变量表index为1的值是0，操作数栈顶的值也是0）  
3：iinc是对int类型的值进行自增操作，后面第一个数值1表示，局部变量表的index值，说明要对此值执行iinc操作，第二个数值1表示要增加的数值。（这时局部变量表index为1的值因为执行了自增操作变为1了，但是操作数栈中栈顶的值仍然是0）  
6：将操作数栈顶的值弹出（值0），放到局部变量表index为1的位置（0替换了1），覆盖了上一步局部变量表的计算结果。  
事实上`i++`操作对应2,3,6三步。很明显，`i++`<b>不是原子操作</b>  

### 下面主要说说内存模型  
Java内存模型定义了把JVM中的变量存储到内存和从内存中读取出变量的访问规则，这里的变量不算Java栈内的局部变量，因为Java栈是线程私有的，不存在共享问题。细节上讲，JVM中有一块主内存（不是完全对应物理机主内存的那个概念，这里说的JVM的主内存是JVM的一部分，它主要对应Java堆中的对象实例及其相关信息的存储部分）存储了Java的所有变量。且Java的每一个线程都有一个工作内存（对应Java栈），里面存放了JVM主内存中变量的值的拷贝！且Java线程的工作内存和JVM的主内存独立！如图：  
![b]({{ "/img/post/JMM/1.png" | prepend: site.baseurl }} )
Java内存模型定义了以下八种操作来完成：  
lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。  
unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。  
read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。  
load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。  
use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。  
assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。  
store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。  
write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。  
这8个操作都是原子操作，但对于64位的数据类型（long和double）具有非原子协定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为2次32位操作进行。  
当数据从JVM的主内存复制一份拷贝到Java线程的工作内存存储时，必须出现两个动作：  
　1.由JVM主内存执行的读（read）操作；  
　2.由Java线程的工作内存执行相应的load操作。  
反过来，当数据从线程的工作内存拷贝到JVM的主内存时，也出现两个操作：  
　1.由Java线程的工作内存执行的存储（store）操作；  
　2.由JVM主内存执行的相应的写（write）操作。  
两个操作必须按顺序执行，而没有保证必须是连续执行。 read，load，store，write的操作都是原子的，即执行期间不会被中断！但是各个原子操作之间可能会发生中断！对于普通变量，如果一个线程中主内存变量值的拷贝更新了，并不能马上反应在其他变量中，因为Java的每个线程都私有一个工作内存，里面存储了该条线程需要用到的JVM主内存中的变量拷贝！（比如实例的字段信息，类型的静态变量，数组，对象……）如图：  
![c]({{ "/img/post/JMM/2.png" | prepend: site.baseurl }} ) 
线程A、B、C对变量的所有操作（读取、赋值等）都必须在各自的工作内存中进行！而A、B使用的数据从各自的工作内存传递到同一块JVM主内存的这个过程是有时差的，或者说是有隔离的！通俗的说他们之间看不见！也就是之前说的一个线程中的变量被修改了，是无法立即让其他线程看见的！如果需要在其他线程中立即可见，需要使用 volatile 关键字。  
一旦一个共享变量（成员、静态）被volatile修饰，那么就意味着：A线程修改了该变量的值，则这个新的值对其他线程来说，是立即可见的。  

看个例子：  
```
//线程A
boolean flag = false;
while(!flag) {
	System.out.print("0");
}

//线程B
flag = true;
```
这样的程序可能会有bug，一旦发生后果很严重。  
线程A和B需要通信的时候，第一步A线程会将本地工作内存中的flag变量的值刷新到JVM主内存中，主内存的flag=false，第二步，线程B再去主内存中读取flag的拷贝，临时存储在B，此时B中工作内存的flag也为false了。当线程B更改了flag变量的值为true之后，同样也需要做类似线程A那样的工作……但是此时此刻，恰恰B还没来得及把更新之后的flag写入主存当中（前面说了各个原子操作之间可以中断），就转去做其他事情了，那么线程A由于不知道线程B对flag变量的更改，因此还会一直循环下去。这就是死循环的潜在bug！  

如果flag使用了volatile修饰，会使得：  
B线程更新flag值为true，会强制将修改后的值立即写入JVM主内存，不许原子操作之间中断。
线程B修改flag时，也会让线程A的工作内存中的flag缓存行失效！因为A线程的工作内存中JVM主内存的flag的拷贝值缓存行无效了，所以A线程再次读取flag的值会去JVM主内存读取。  
这样A得到的就是最新的正确的flag值——true。程序完美的实现了中断。但是volatile不能代替锁，因为它不是线程安全的，即volatile修饰符无法保证对变量的任何操作都是原子的！  

关键字volatile的语义除了保证不同线程对共享变量操作的可见性，还能禁止指令重排序！也就是保证有序性。  
在本线程内，所有的操作看起来都是有序的，但是在本线程之外（其他线程）观察，这些操作都是无序的。前半句指“线程内表现为串行的语义”（as-if-serial），后半句值“指令重排序”或普通变量的“工作内存与主内存同步延迟”的现象。  
一个可重排语句如下：  
```
int a = 1;
int b = 1;
```
先给a赋值，和先给b赋值，其实没什么区别，效果是一样的，这样的代码就是可重排代码，编译器会针对上下文对指令做顺序调整，哪个顺序好，就用哪个，所以实际上两句话怎么个执行顺序，是不一定的。  
#### happen-before原则
有可重排就自然会有不可重排，首先要知道Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够保证有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。反之遵循了happen-before原则，JVM就无法对指令进行重排序（看起来的）。  
- 程序次序规则：在一个线程内，书写在前面的操作先行发生于书写在后面的操作，就像刚刚说的，一段代码的执行在单个线程中看起来是有序的，程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作，这是一条比较重要的规则。就是说如果一个线程先去写一个volatile变量，然后另一个线程去读取，那么写入操作肯定会先行发生于读操作。
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C，实际上就是体现happens-before原则具备传递性。  

　　**事实上，这个规则是用来保证程序在单线程中执行结果的正确性，无法保证在多线程中执行的正确性。**  

