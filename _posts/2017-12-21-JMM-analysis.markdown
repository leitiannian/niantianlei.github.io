---
layout:     post
title:      "再谈Java内存模型"
subtitle:   " \"JMM\""

author:     "Nian Tianlei"
header-img: "img/post-bg-2016.jpg"
header-mask: 0.4
catalog:    true
tags:
    - Java
---


之前写过一个关于JMM的[博客](https://niantianlei.github.io/2017/09/26/JMM/)，但没有深入，也不够具体。  





Java线程间的通信由Java内存模型，也就是JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。  
JMM定义了*线程与主内存*之间的关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程读/写共享变量的副本。本地内存是一个抽象概念，并不真实存在。  
所有实例域、静态域和数组元素（共享变量）都存储在堆内存中，堆内存在线程之间共享。  
局部变量不会在线程之间共享，不存在内存可见性问题，不受JMM影响。  
![a]({{ "/img/post/JMM/model.png" | prepend: site.baseurl }} )  
如图，线程A和线程B的通信必须经过两个步骤：  
1.线程A把本地内存中更新过的共享变量写回到主内存；  
2.线程B到主内存中读取线程A更新过的共享变量。    
可见，线程A，B的通信过程必须经过主内存。  

### 重排序
在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。
1)编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
2)指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
3)内存系统的重排序。由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序执行。  
其中，第一种是编译器重排序，后两种属于处理器重排序。  这些重排序可能会导致多线程程序出现内存可见性问题。  

**解决方法：**编译器重排序规则会禁止特定类型的编译器重排序；Java编译器在生产指令序列时会插入特定类型的内存屏障，禁止特定类型的处理器重排序。

### happens-before规则
JDK 5开始，JSR-133内存模型使用happens-before 概念来阐述操作之间的内存可见性。若一个操作A的执行结果对另一个操作B可见，则两个操作必须满足`A happens-before B` 关系。当然，这两个操作可以是在一个线程内，也可以是不同线程间。  

happens-before仅仅要求前一个操作（执行结果）对后一个操作可见，并且前一个操作按顺序排在第二个操作之前。并不意味着前一个操作必须要在后一个操作之前执行。  
如果重排序之后的执行结果与按照happens-before规则的执行结果一致，那么这种重排序并不非法。  

一些规则：  
1)程序顺序规则:一个线程中的每个操作，happens-before于该线程中的任意后续操作。  
2)监视器锁规则:对一个锁的解锁，happens-before于随后对这个锁的加锁。  
3)volatile变量规则:对一个volatile域的写，happens-before于任意后续对这个volatile域的读。  
4)传递性:如果A happens-before B，且B happens-before C,那么A happens-before C。  

### 数据依赖性
如果两个操作访问同一个变量，且其中一个操作是写操作，此时两个操作之间存在数据依赖性。  
只要重排序两个操作的执行顺序吗，程序的执行结果就会改变。  
此时，编译器和处理器不会重排序存在数据依赖关系的两个操作。  
这里的数据依赖性仅针对单个处理器执行的指令序列和单个线程中执行的操作。  

### as-if-serial语义
as-if-serial语义：不管怎样重排序，（单线程）程序的执行结果不能改变。  
编译器和处理器都必须遵守as-if-serial语义，不会对存在数据依赖关系的操作做重排序；如果不存在数据依赖关系，则有可能被重排序。  

### 顺序一致性
顺序一致性内存模型是理论参考模型，其特性有：  
1.一个线程中的所有操作必须按照程序的顺序来执行。  
2.（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。  

JMM不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。未同步程序，整体是无序的，执行结果无法预知。  

JMM不保证对64位的long型和double型变量的写操作具有原子性，这一点在上一个博客已经写明。顺序一致性内存模型保证对所有的内存读/写操作都具有原子性。  
在一些32位处理器上，若对64位数据的写操作具有原子性，会有较大开销。JVM可能会把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行。这两个写操作可能会被分配到不同的总线事务中执行，此时对这个64位变量的写操作不具有原子性。  

### volatile的内存语义
volatile变量特性：  
可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。  
原子性：对于任意单个volatile变量的读/写具有原子性,但是类似与volatileVal++这种复合操作来说,它就不具有原子性。  
即使64位的long/double型变量，只要是volatile变量，读/写就具有原子性。  

volatile不会引起线程上下文切换，相当于轻量级的synchronized。  
适用条件：对变量的写操作不依赖当前值，如a++不保证原子性；  


volatile写的内存语义：
当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量值刷新到主内存。  
volatile读的内存语义：
当读一个volatile变量时，JMM会把线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。  

### volatile内存语义的实现
为了实现volatile的内存语义，禁止特定的编译器重排序和处理器重排序即可。  

一、JMM针对编译器制定的volatile重排序规则表：  

| 操作1\操作2 | 普通读/写 | volatile读 | volatile写 | 
| - | :-: | :-: | :-: | 
| 普通读/写 |  |   | NO | 
| volatile读 | NO | NO | NO | 
| volatile写 |   | NO | NO |

当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。  
当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。  
当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。  

二、编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的JMM内存屏障插入策略：  
在每个volatile写操作的前面插入一个StoreStore屏障；  
在每个volatile写操作的后面插入一个StoreLoad屏障；  
在每个volatile读操作的前面插入一个LoadLoad屏障；  
在每个volatile读操作的后面插入一个LoadStore屏障。  

这种保守型的内存屏障可以保证在任意处理器平台，任意程序中都能得到正确的volatile内存语义。  
严格限制对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。  
volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行特性可以确保对整个临界区代码的执行具有原子性。  

### volatile的优化
JDK 7在并发包中新增了LinkedTransferQueue，在使用volatile变量时，会追加字节的方式来优化入队和出队的性能。  

这是因为，大多数处理器的高速缓存行是64个字节宽。如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，在多处理器的情况下将会严重影响到队列的入队和出队效率。  
使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头接点和尾节点加载到同一个缓存行，使得头尾节点在修改时不会互相锁定。

### 锁的内存语义
锁可以让临界区互斥执行  
当线程释放锁的时候，JMM会把线程对应的本地内存中的共享变量刷新到主内存中；  
当线程获取锁时，JMM会把线程对应的本地内存置为无效，
从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。  

### 锁内存语义的实现
对于公平锁来说，加锁方法首先读volatile变量state；释放锁的最后写volatile变量state。  
根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。  

对于非公平锁，释放锁与公平锁完全一样。获取锁，会用CAS更新volatile变量state。  
因为编译器不会对volatile读与其后面的操作重排序，也不会对volatile写和其前面的操作重排序。所以，编译器不能对CAS与CAS前面和后面的任意内存操作重排序。  
程序会根据当前处理器类型决定是否为cmpxchg指令添加lock前缀。如果在多处理器上运行，加上lock前缀；在单处理器上运行，省略lock前缀。（单处理器自身会维护顺序一致性，不需要lock前缀提供内存屏障）  
而lock前缀可以禁止该指令，与之前和之后的读和写指令重排序；并把写缓冲区中的所有数据刷新到内存中。  
所以CAS可以同时实现volatile读和volatile写的内存语义。  

### CAS算法
CAS算法大致原理是：在对变量进行计算之前，首先读取原变量值，称为 旧的预期值A，然后在更新之前再获取当前内存中的值，称为 当前内存值 V，如果 A==V 则说明变量从未被其他线程修改过，此时将会写入新值 B，如果 A!=V 则说明变量已经被其他线程修改过，当前线程应当什么也不做；  
CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。


CAS缺点  
1.  ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。  
2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。  
3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。